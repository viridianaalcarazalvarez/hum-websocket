<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hum with me</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: crosshair;
            height: 100vh;
            width: 100vw;
        }

        #canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #threejs-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        #usernameModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        #usernameModal.hidden {
            display: none;
        }

        #usernameForm {
            background: #111;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            min-width: 300px;
        }

        #usernameForm h2 {
            margin-bottom: 20px;
            color: #fff;
        }

        #usernameForm input {
            width: 100%;
            padding: 12px;
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
            outline: none;
        }

        #usernameForm input:focus {
            border-color: #0f0;
        }

        #usernameForm button {
            padding: 12px 30px;
            background: #0f0;
            border: none;
            border-radius: 5px;
            color: #000;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
        }

        #usernameForm button:hover {
            background: #0a0;
        }

        #usernameError {
            color: #f00;
            font-size: 12px;
            margin-top: 10px;
            min-height: 20px;
        }

        #onlineUsers {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
            min-width: 200px;
            max-width: 300px;
        }

        #onlineUsers h3 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #0f0;
        }

        #userList {
            list-style: none;
            max-height: 300px;
            overflow-y: auto;
        }

        #userList li {
            padding: 5px 0;
            border-bottom: 1px solid #222;
        }

        #userList li:last-child {
            border-bottom: none;
        }

        #userCount {
            color: #888;
            font-size: 12px;
            margin-top: 10px;
        }

        .click-effect {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
            pointer-events: none;
            animation: ripple 0.6s ease-out;
            transform: translate(-50%, -50%);
            filter: blur(1px);
        }

        @keyframes ripple {
            0% {
                transform: translate(-50%, -50%) scale(0) translateZ(0);
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.8),
                            0 0 0 0 rgba(255, 255, 255, 0.6),
                            0 0 0 0 rgba(255, 255, 255, 0.4);
            }
            50% {
                transform: translate(-50%, -50%) scale(2) translateZ(20px);
                opacity: 0.8;
                box-shadow: 0 0 30px 10px rgba(255, 255, 255, 0.6),
                            0 0 60px 20px rgba(255, 255, 255, 0.4),
                            0 0 90px 30px rgba(255, 255, 255, 0.2);
            }
            100% {
                transform: translate(-50%, -50%) scale(4) translateZ(0);
                opacity: 0;
                box-shadow: 0 0 60px 20px rgba(255, 255, 255, 0),
                            0 0 120px 40px rgba(255, 255, 255, 0),
                            0 0 180px 60px rgba(255, 255, 255, 0);
            }
        }

    </style>
</head>
<body>
    <div id="usernameModal">
        <div id="usernameForm">
            <h2>enter ur username</h2>
            <input type="text" id="usernameInput" placeholder="here [:" maxlength="20" autocomplete="off">
            <button id="usernameSubmit">join</button>
            <div id="usernameError"></div>
        </div>
    </div>
    <div id="onlineUsers">
        <h3>online users</h3>
        <ul id="userList"></ul>
        <div id="userCount">0 users online</div>
    </div>
    <div id="threejs-container"></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const usernameModal = document.getElementById('usernameModal');
        const usernameInput = document.getElementById('usernameInput');
        const usernameSubmit = document.getElementById('usernameSubmit');
        const usernameError = document.getElementById('usernameError');
        const userList = document.getElementById('userList');
        const userCount = document.getElementById('userCount');

        let currentUsername = null;
        let isRegistered = false;
        let lastOtherUserClick = null; // Store last click from other users
        let lastMyClick = null; // Store last click from current user

        // Store all clicks for connections and blobs
        const allClicks = []; // Array of {x, y, color, id, blob, username}
        
        // Three.js setup
        let scene, camera, renderer;
        let blobMeshes = []; // Store all blob meshes
        let connectionLines = []; // Store all connection lines
        const BLOB_MERGE_DISTANCE = 80; // Distance threshold for blob merging
        const BLOB_BASE_SIZE = 20;

        // Initialize Three.js
        function initThreeJS() {
            const container = document.getElementById('threejs-container');
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 200, 2000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 2000);
            camera.position.z = 500;
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Add directional light for 3D effect
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-1, 1, 1);
            scene.add(directionalLight);
            
            // Add point lights for glow
            const pointLight1 = new THREE.PointLight(0xffffff, 0.5, 1000);
            pointLight1.position.set(0, 0, 500);
            scene.add(pointLight1);
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Update blob morphing
                updateBlobs();
                
                renderer.render(scene, camera);
            }
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });
        }

        // Convert screen coordinates to Three.js world coordinates
        function screenToWorld(x, y) {
            const mouse = new THREE.Vector2();
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            return intersectPoint;
        }

        // Create a blob mesh (using sphere with morphing capability)
        function createBlob(x, y, color = '#ffffff', username = null) {
            const worldPos = screenToWorld(x, y);
            
            // Create sphere geometry with more segments for smooth morphing
            const geometry = new THREE.SphereGeometry(BLOB_BASE_SIZE, 32, 32);
            
            // Store original positions for morphing
            const originalPositions = new Float32Array(geometry.attributes.position.array.length);
            originalPositions.set(geometry.attributes.position.array);
            
            // Create material with glow
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.6,
                shininess: 100,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(worldPos.x, worldPos.y, Math.random() * 30 - 15);
            mesh.userData = {
                originalRadius: BLOB_BASE_SIZE,
                targetRadius: BLOB_BASE_SIZE,
                basePosition: new THREE.Vector3(worldPos.x, worldPos.y, mesh.position.z),
                color: color,
                username: username,
                pulsePhase: Math.random() * Math.PI * 2,
                originalPositions: originalPositions
            };
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(BLOB_BASE_SIZE * 1.3, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(mesh.position);
            glow.userData.parent = mesh;
            scene.add(glow);
            
            scene.add(mesh);
            
            // Animate blob appearance
            mesh.scale.set(0, 0, 0);
            const scaleTarget = 1;
            const animateScale = () => {
                if (mesh.scale.x < scaleTarget) {
                    mesh.scale.x += 0.15;
                    mesh.scale.y += 0.15;
                    mesh.scale.z += 0.15;
                    requestAnimationFrame(animateScale);
                }
            };
            animateScale();
            
            return { mesh, glow, worldPos };
        }

        // Update blob morphing based on proximity
        function updateBlobs() {
            const time = Date.now() * 0.001;
            
            blobMeshes.forEach((blobData, i) => {
                const mesh = blobData.mesh;
                const glow = blobData.glow;
                const userData = mesh.userData;
                
                // Check if initial scale animation is complete
                const isAnimating = mesh.scale.x < 0.95;
                
                // Pulse animation (only apply if animation is complete)
                const pulse = isAnimating ? 1 : (Math.sin(time * 2 + userData.pulsePhase) * 0.08 + 1);
                
                // Check proximity to other blobs
                let mergeScale = 1;
                let mergeOffset = new THREE.Vector3(0, 0, 0);
                let nearbyCount = 0;
                
                blobMeshes.forEach((otherBlobData, j) => {
                    if (i === j) return;
                    
                    const otherMesh = otherBlobData.mesh;
                    const distance = mesh.position.distanceTo(otherMesh.position);
                    
                    if (distance < BLOB_MERGE_DISTANCE) {
                        const mergeStrength = 1 - (distance / BLOB_MERGE_DISTANCE);
                        mergeScale += mergeStrength * 0.3;
                        
                        // Attract towards nearby blobs
                        const direction = new THREE.Vector3()
                            .subVectors(otherMesh.position, mesh.position)
                            .normalize();
                        mergeOffset.add(direction.multiplyScalar(mergeStrength * 2));
                        nearbyCount++;
                    }
                });
                
                // Apply morphing
                const targetRadius = userData.originalRadius * mergeScale;
                userData.targetRadius += (targetRadius - userData.targetRadius) * 0.1;
                
                // Morph geometry
                const positions = mesh.geometry.attributes.position;
                const originalPositions = userData.originalPositions;
                
                for (let k = 0; k < positions.count; k++) {
                    const i3 = k * 3;
                    const x = originalPositions[i3];
                    const y = originalPositions[i3 + 1];
                    const z = originalPositions[i3 + 2];
                    
                    // Calculate distance from center
                    const dist = Math.sqrt(x * x + y * y + z * z);
                    const normalizedDist = dist / userData.originalRadius;
                    
                    // Apply blob morphing (smooth expansion)
                    const newDist = normalizedDist * userData.targetRadius;
                    const factor = newDist / dist;
                    
                    positions.array[i3] = x * factor;
                    positions.array[i3 + 1] = y * factor;
                    positions.array[i3 + 2] = z * factor;
                }
                
                positions.needsUpdate = true;
                mesh.geometry.computeVertexNormals();
                
                // Apply position offset for attraction
                if (nearbyCount > 0) {
                    mergeOffset.divideScalar(nearbyCount);
                    const targetPos = userData.basePosition.clone().add(mergeOffset);
                    mesh.position.lerp(targetPos, 0.05);
                } else {
                    mesh.position.lerp(userData.basePosition, 0.05);
                }
                
                // Update glow
                if (glow) {
                    glow.position.copy(mesh.position);
                    glow.scale.copy(mesh.scale);
                    glow.scale.multiplyScalar(1.3);
                }
                
                // Apply pulse (only if not animating, otherwise let animateScale handle it)
                if (!isAnimating) {
                    mesh.scale.setScalar(pulse);
                }
            });
        }

        // Create connection line between two points
        function createConnectionLine(x1, y1, x2, y2, color = '#ffffff') {
            const pos1 = screenToWorld(x1, y1);
            const pos2 = screenToWorld(x2, y2);
            
            // Add some Z variation
            pos1.z = Math.random() * 20 - 10;
            pos2.z = Math.random() * 20 - 10;
            
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(pos1.x, pos1.y, pos1.z),
                new THREE.Vector3(pos2.x, pos2.y, pos2.z)
            ]);
            
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                linewidth: 2
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            return line;
        }

        // Connect all clicks with lines
        function updateConnections() {
            // Remove old connection lines
            connectionLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            connectionLines = [];
            
            // Connect each click to nearby clicks (within connection distance)
            const CONNECTION_DISTANCE = 300; // Screen pixels
            
            for (let i = 0; i < allClicks.length; i++) {
                for (let j = i + 1; j < allClicks.length; j++) {
                    const click1 = allClicks[i];
                    const click2 = allClicks[j];
                    
                    const distance = Math.sqrt(
                        Math.pow(click2.x - click1.x, 2) + 
                        Math.pow(click2.y - click1.y, 2)
                    );
                    
                    if (distance < CONNECTION_DISTANCE) {
                        // Use the color of the more recent click
                        const lineColor = click2.color;
                        const line = createConnectionLine(
                            click1.x, click1.y, 
                            click2.x, click2.y, 
                            lineColor
                        );
                        connectionLines.push(line);
                    }
                }
            }
        }

        // Audio context for piano sounds
        let audioContext = null;
        let reverbNode = null;
        let userBaseNote = null; // Base note index for current user in C# minor scale
        
        // C# minor scale notes (C#, D#, E, F#, G#, A, B, C#)
        const cSharpMinorScale = [
            277.18,  // C#4
            311.13,  // D#4
            329.63,  // E4
            369.99,  // F#4
            415.30,  // G#4
            440.00,  // A4
            493.88,  // B4
            554.37,  // C#5
            622.25,  // D#5
            659.25,  // E5
            739.99,  // F#5
            830.61,  // G#5
            880.00,  // A5
            987.77,  // B5
            1108.73  // C#6
        ];

        // Initialize audio context and reverb
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                createReverb();
            } catch (e) {
                console.error('Audio context not supported:', e);
            }
        }

        // Create reverb effect using delay nodes
        function createReverb() {
            if (!audioContext) return;
            
            // Create reverb using multiple delay lines
            const reverbGain = audioContext.createGain();
            reverbGain.gain.value = 0.4;
            
            const delays = [
                { time: 0.03, feedback: 0.3 },
                { time: 0.05, feedback: 0.25 },
                { time: 0.07, feedback: 0.2 },
                { time: 0.09, feedback: 0.15 }
            ];
            
            const delayNodes = delays.map(delay => {
                const delayNode = audioContext.createDelay(1);
                const feedbackGain = audioContext.createGain();
                const outputGain = audioContext.createGain();
                
                delayNode.delayTime.value = delay.time;
                feedbackGain.gain.value = delay.feedback;
                outputGain.gain.value = 0.25;
                
                delayNode.connect(feedbackGain);
                feedbackGain.connect(delayNode);
                delayNode.connect(outputGain);
                outputGain.connect(reverbGain);
                
                return { input: delayNode, output: outputGain };
            });
            
            reverbNode = {
                input: audioContext.createGain(),
                output: reverbGain,
                delays: delayNodes
            };
            
            reverbNode.input.connect(reverbGain);
            delayNodes.forEach(d => reverbNode.input.connect(d.input));
            reverbGain.connect(audioContext.destination);
        }

        // Get base note for a user (based on username hash, mapped to C# minor scale)
        function getUserBaseNote(username) {
            if (!username) return 0;
            let hash = 0;
            for (let i = 0; i < username.length; i++) {
                hash = username.charCodeAt(i) + ((hash << 5) - hash);
            }
            return Math.abs(hash) % cSharpMinorScale.length;
        }

        // Get note from position (maps to C# minor scale)
        function getNoteFromPosition(x, y, baseNoteIndex) {
            // Map position to scale notes
            const xNote = Math.floor((x / window.innerWidth) * 8) % 8; // 8 notes in octave
            const yOctave = Math.floor((y / window.innerHeight) * 2); // 0-2 octaves
            
            const noteIndex = (baseNoteIndex + xNote + (yOctave * 8)) % cSharpMinorScale.length;
            return cSharpMinorScale[noteIndex];
        }

        // Play rompler piano sound
        function playPianoNote(frequency, duration = 1.2, volume = 0.4, color = '#fff') {
            if (!audioContext) {
                initAudio();
                if (!audioContext) return;
            }

            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const now = audioContext.currentTime;
            const masterGain = audioContext.createGain();
            
            // Create piano-like sound with multiple oscillators (fundamental + harmonics)
            const oscillators = [];
            const harmonics = [
                { freq: 1.0, gain: 1.0 },    // Fundamental
                { freq: 2.0, gain: 0.5 },    // Octave
                { freq: 3.0, gain: 0.3 },    // Fifth + octave
                { freq: 4.0, gain: 0.15 },  // Two octaves
                { freq: 6.0, gain: 0.1 }    // Higher harmonic
            ];

            harmonics.forEach((harmonic, index) => {
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                
                // Use different waveforms for richness
                if (index === 0) {
                    osc.type = 'sine'; // Fundamental is pure
                } else if (index < 3) {
                    osc.type = 'triangle'; // Mid harmonics
                } else {
                    osc.type = 'sine'; // High harmonics
                }
                
                osc.frequency.setValueAtTime(frequency * harmonic.freq, now);
                
                // Piano-like envelope: quick attack, slow decay
                const attackTime = 0.01 + (index * 0.005);
                const decayTime = 0.1;
                const sustainLevel = 0.3;
                const releaseTime = duration * 0.7;
                
                oscGain.gain.setValueAtTime(0, now);
                oscGain.gain.linearRampToValueAtTime(volume * harmonic.gain, now + attackTime);
                oscGain.gain.linearRampToValueAtTime(volume * harmonic.gain * sustainLevel, now + attackTime + decayTime);
                oscGain.gain.linearRampToValueAtTime(volume * harmonic.gain * sustainLevel, now + duration - releaseTime);
                oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(oscGain);
                oscGain.connect(masterGain);
                
                osc.start(now);
                osc.stop(now + duration);
                
                oscillators.push(osc);
            });

            // Add slight detuning for realism
            oscillators.forEach((osc, i) => {
                if (i > 0) {
                    const detune = (Math.random() - 0.5) * 2; // Â±1 cent
                    osc.detune.setValueAtTime(detune, now);
                }
            });

            // Connect to reverb
            if (reverbNode) {
                masterGain.connect(reverbNode.input);
            }
            masterGain.connect(audioContext.destination);
        }

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;
        let ws = null;
        let clickCount = 0;

        function connect() {
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                // Don't hide modal yet - wait for username registration
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleMessage(data);
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };

            ws.onclose = () => {
                isRegistered = false;
                usernameModal.classList.remove('hidden');
                setTimeout(connect, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // Username form handling
        function submitUsername() {
            const username = usernameInput.value.trim();
            if (!username) {
                usernameError.textContent = 'Please enter a username';
                return;
            }

            if (username.length < 1 || username.length > 20) {
                usernameError.textContent = 'Username must be between 1 and 20 characters';
                return;
            }

            if (ws && ws.readyState === WebSocket.OPEN) {
                usernameError.textContent = '';
                ws.send(JSON.stringify({
                    type: 'register',
                    username: username
                }));
            }
        }

        usernameSubmit.addEventListener('click', submitUsername);
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitUsername();
            }
        });

        function updateUserList(users) {
            userList.innerHTML = '';
            users.forEach(username => {
                const li = document.createElement('li');
                li.textContent = username;
                if (username === currentUsername) {
                    li.style.color = '#0f0';
                    li.textContent = username + ' (you)';
                }
                userList.appendChild(li);
            });
            userCount.textContent = `${users.length} user${users.length !== 1 ? 's' : ''} online`;
        }

        function handleMessage(data) {
            if (data.type === 'registered') {
                currentUsername = data.username;
                isRegistered = true;
                userBaseNote = getUserBaseNote(data.username);
                usernameModal.classList.add('hidden');
                usernameInput.value = '';
                usernameError.textContent = '';
                // Initialize audio when user registers
                initAudio();
            } else if (data.type === 'usernameError') {
                usernameError.textContent = data.message;
            } else if (data.type === 'userList') {
                updateUserList(data.users);
            } else if (data.type === 'userJoined') {
                // Could show a notification here if desired
                console.log(`${data.username} joined`);
            } else if (data.type === 'userLeft') {
                // Could show a notification here if desired
                console.log(`${data.username} left`);
            } else if (data.type === 'echo') {
                // Handle echo from server
                if (data.original && data.original.type === 'click') {
                    // Visual feedback for echoed clicks
                }
            } else if (data.type === 'broadcast') {
                // Handle broadcast from other clients
                if (data.data && data.data.type === 'click') {
                    const otherX = data.data.x;
                    const otherY = data.data.y;
                    const otherUsername = data.username;
                    
                    // Draw the other user's click (this will create blob and update connections)
                    drawClick(otherX, otherY, '#0f0', true, otherUsername);
                    
                    // If we have a previous click from us, draw a line
                    if (lastMyClick) {
                        drawLine(lastMyClick.x, lastMyClick.y, otherX, otherY, '#0f0');
                    }
                    
                    // Play piano sound for other user's click
                    if (otherUsername) {
                        const otherBaseNote = getUserBaseNote(otherUsername);
                        const frequency = getNoteFromPosition(otherX, otherY, otherBaseNote);
                        playPianoNote(frequency, 1.2, 0.35, '#0f0');
                    }
                    
                    // Update last other user click
                    lastOtherUserClick = { x: otherX, y: otherY };
                }
            }
        }

        function drawClick(x, y, color = '#fff', fromOtherUser = false, username = null) {
            // Enhanced ripple effect with 3D appearance
            const effect = document.createElement('div');
            effect.className = 'click-effect';
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            effect.style.borderColor = color;
            effect.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}, 0 0 60px ${color}`;
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 600);

            // Create 3D blob if Three.js is initialized
            if (scene && renderer) {
                const threeColor = color === '#fff' ? '#ffffff' : '#00ff00';
                const blobData = createBlob(x, y, threeColor, username);
                const clickId = Date.now() + Math.random();
                
                // Store click data
                const clickData = {
                    x, y, color, id: clickId,
                    blob: blobData,
                    username: username || currentUsername
                };
                allClicks.push(clickData);
                blobMeshes.push(blobData);
                
                // Update connections
                updateConnections();
            }

            // Set composite operation for blending
            ctx.globalCompositeOperation = 'screen';
            
            const baseRadius = 30;
            const numLayers = 8;
            
            // Create main 3D sphere effect with multiple layers
            for (let i = 0; i < numLayers; i++) {
                const radius = baseRadius - (i * 3);
                const opacity = 0.5 - (i * 0.05);
                
                // Create 3D sphere gradient (light from top-left)
                const highlightX = x - radius * 0.3;
                const highlightY = y - radius * 0.3;
                const gradient = ctx.createRadialGradient(
                    highlightX, highlightY, 0, 
                    x, y, radius
                );
                
                if (color === '#fff') {
                    // White with highlight
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity * 1.2})`);
                    gradient.addColorStop(0.2, `rgba(255, 255, 255, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(240, 240, 240, ${opacity * 0.8})`);
                    gradient.addColorStop(0.7, `rgba(200, 200, 200, ${opacity * 0.6})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                } else {
                    // Green with highlight
                    gradient.addColorStop(0, `rgba(100, 255, 100, ${opacity * 1.2})`);
                    gradient.addColorStop(0.2, `rgba(0, 255, 0, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(0, 220, 0, ${opacity * 0.8})`);
                    gradient.addColorStop(0.7, `rgba(0, 180, 0, ${opacity * 0.6})`);
                    gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Add bright highlight spot (3D shine effect)
            const highlightRadius = baseRadius * 0.4;
            const highlightGradient = ctx.createRadialGradient(
                x - baseRadius * 0.25, y - baseRadius * 0.25, 0,
                x - baseRadius * 0.25, y - baseRadius * 0.25, highlightRadius
            );
            if (color === '#fff') {
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            } else {
                highlightGradient.addColorStop(0, 'rgba(150, 255, 150, 0.9)');
                highlightGradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.5)');
                highlightGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
            }
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.arc(x - baseRadius * 0.25, y - baseRadius * 0.25, highlightRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add depth shadow (bottom-right)
            const shadowOffset = baseRadius * 0.15;
            const shadowGradient = ctx.createRadialGradient(
                x + shadowOffset, y + shadowOffset, 0,
                x + shadowOffset, y + shadowOffset, baseRadius * 0.6
            );
            if (color === '#fff') {
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            } else {
                shadowGradient.addColorStop(0, 'rgba(0, 100, 0, 0.4)');
                shadowGradient.addColorStop(1, 'rgba(0, 100, 0, 0)');
            }
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            ctx.arc(x + shadowOffset, y + shadowOffset, baseRadius * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // Add dimensional bleeding spots with depth
            for (let j = 0; j < 4; j++) {
                const angle = (j / 4) * Math.PI * 2;
                const distance = 25 + Math.random() * 15;
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;
                const bleedRadius = 12 + Math.random() * 8;
                const bleedOpacity = 0.2 + Math.random() * 0.15;
                
                const bleedGradient = ctx.createRadialGradient(
                    x + offsetX, y + offsetY, 0, 
                    x + offsetX, y + offsetY, bleedRadius
                );
                
                if (color === '#fff') {
                    bleedGradient.addColorStop(0, `rgba(255, 255, 255, ${bleedOpacity})`);
                    bleedGradient.addColorStop(0.6, `rgba(255, 255, 255, ${bleedOpacity * 0.5})`);
                    bleedGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                } else {
                    bleedGradient.addColorStop(0, `rgba(0, 255, 0, ${bleedOpacity})`);
                    bleedGradient.addColorStop(0.6, `rgba(0, 255, 0, ${bleedOpacity * 0.5})`);
                    bleedGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                }
                
                ctx.fillStyle = bleedGradient;
                ctx.beginPath();
                ctx.arc(x + offsetX, y + offsetY, bleedRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawLine(x1, y1, x2, y2, color = '#fff') {
            // Set composite for blending
            ctx.globalCompositeOperation = 'screen';
            
            // Draw multiple overlapping lines with gradients for bleeding effect
            const numLines = 3;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            
            for (let i = 0; i < numLines; i++) {
                const lineWidth = 8 - (i * 2);
                const opacity = 0.4 - (i * 0.1);
                
                // Create gradient along the line
                const lineGradient = ctx.createLinearGradient(x1, y1, x2, y2);
                if (color === '#fff') {
                    lineGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                    lineGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.8})`);
                    lineGradient.addColorStop(1, `rgba(255, 255, 255, ${opacity})`);
                } else {
                    lineGradient.addColorStop(0, `rgba(0, 255, 0, ${opacity})`);
                    lineGradient.addColorStop(0.5, `rgba(0, 255, 0, ${opacity * 0.8})`);
                    lineGradient.addColorStop(1, `rgba(0, 255, 0, ${opacity})`);
                }
                
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Add some bleeding spots along the line
            const numBleeds = Math.floor(distance / 30);
            for (let j = 0; j < numBleeds; j++) {
                const t = (j + 1) / (numBleeds + 1);
                const bleedX = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 10;
                const bleedY = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 10;
                const bleedRadius = 8 + Math.random() * 5;
                
                const bleedGradient = ctx.createRadialGradient(bleedX, bleedY, 0, bleedX, bleedY, bleedRadius);
                if (color === '#fff') {
                    bleedGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                    bleedGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                } else {
                    bleedGradient.addColorStop(0, 'rgba(0, 255, 0, 0.2)');
                    bleedGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                }
                
                ctx.fillStyle = bleedGradient;
                ctx.beginPath();
                ctx.arc(bleedX, bleedY, bleedRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }

        // Handle clicks
        canvas.addEventListener('click', (e) => {
            if (!isRegistered) return; // Don't allow clicks until registered
            
            const x = e.clientX;
            const y = e.clientY;
            clickCount++;

            // Draw the click (this will create blob and update connections)
            drawClick(x, y, '#fff', false, currentUsername);
            
            // Play piano sound for your click
            if (userBaseNote !== null) {
                const frequency = getNoteFromPosition(x, y, userBaseNote);
                playPianoNote(frequency, 1.2, 0.4, '#fff');
            }
            
            // If we have a previous click from another user, draw a line
            if (lastOtherUserClick) {
                drawLine(lastOtherUserClick.x, lastOtherUserClick.y, x, y, '#fff');
            }

            // Update last my click
            lastMyClick = { x: x, y: y };

            // Send to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'click',
                    x: x,
                    y: y,
                    timestamp: new Date().toISOString(),
                    clickNumber: clickCount
                }));
            }
        });

        // Initialize audio on page load
        initAudio();

        // Initialize Three.js on page load
        initThreeJS();

        // Connect on load
        connect();
    </script>
</body>
</html>

